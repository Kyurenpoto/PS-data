# 13200

- 난이도: Platinum 3
- 태그: 백트래킹, 브루트포스, 구현, 시뮬레이션

## 문제 설명

- 검은 칸 / 흰 칸으로 이루어진 `N×N` 게임판
- 목표는 흰 칸에 전구를 놓아서 모든 흰 칸을 밝히는 것
- 전구 배치 규칙
  - 흰 칸에만 전구를 놓을 수 있다
  - 검은 칸은 벽이다
  - 전구를 놓은 자리와 동일한 가로/세로줄의, 사이에 벽이 없는 모든 칸이 밝혀진다
  - 두 전구가 동일한 가로/세로줄에 위치하고 사이에 벽이 없다면 과열되기 때문에 배치할 수 없다
  - 검은 칸에 적힌 숫자는 가로/세로로 인접한 전구의 수를 나타낸다

## 입력

- 50개 이하의 테스트 케이스
  - 모든 테스트 케이스는 답이 항상 존재
- 각 테스트 케이스마다 게임 판의 크기(`N <= 7`), 각 칸의 정보

### 제한

- 시간 제한 2초
- 공간 제한 256mb

## 출력

- 전구를 배치한 게임 판

## 풀이

### 단순 백트래킹

N-queen처럼 구현하면 된다. 다만 칸이 밝혀졌다는 것을 표시하기 위해 `O(N)`의 시간복잡도가 필요하다.

최악의 경우 시간 복잡도는 `O(N^3)`, 공간 복잡도는 `O(N^2)`이다.

### 빈 줄 체크를 개선한 백트래킹

기본적으로 모든 흰 칸은 하나의 가로/세로줄에 각각 속한다. 따라서 각 칸이 자신이 속한 가로/세로줄 그룹을 `O(1)`에 알아낼 수 있다면 빈 줄을 체크하는 시간을 `O(N)`에서 `O(1)`으로 개선할 수 있다.

i행 j열 칸의 색을 `R[i][j]`로, 해당 칸이 속한 가로/세로줄 그룹을 각각 `VG[i][j], HG[i][j]`로 표기하자. 그러면 다음과 같은 관계가 성립한다.

``` python
if R[i][j] == R[i][j+1] == white:
    assert VG[i][j] == VG[i][j+1]

if R[i][j] == R[i+1][j] == white:
    assert HG[i][j] == HG[i+1][j]
```

따라서 모든 칸이 속한 그룹을 `O(N^2)`으로 계산할 수 있다.

``` python
if R[i][j] == R[i][j+1] == white:
    VG[i][j+1] = VG[i][j]
elif R[i][j+1] == white:
    VG[i][j+1] = VGNum++;

if R[i][j] == R[i+1][j] == white:
    HG[i+1][j] = HG[i][j]
elif R[i+1][j] == white:
    HG[i+1][j] = HGNum++;
```

이 때 `N <= VGNum, HGNum <= N*(N+1)/2`이므로 공간 복잡도는 `O(N^2)`이다.

빈 줄을 체크하는 시간이 상수가 되었기 때문에, 시간 복잡도는 `O(N^2)`이다.
